// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: pls.proto

package plspb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CredentialClient is the client API for Credential service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CredentialClient interface {
	// Issue creates a new token.
	//
	// If this request is authorized, a child token is created. The child token's
	// expiration may not exceed the expiration of the parent, and the child
	// token's contexts must be a subset of the parent's. When the parent token
	// is deleted, so are any children.
	Issue(ctx context.Context, in *CredentialIssueRequest, opts ...grpc.CallOption) (*CredentialIssueResponse, error)
	// Refresh reissues a token with a new expiration. The returned credential
	// may or may not reuse the same identifier as the request.
	Refresh(ctx context.Context, in *CredentialRefreshRequest, opts ...grpc.CallOption) (*CredentialRefreshResponse, error)
	// Revoke deletes a token and prevents it from being used again. Any children
	// of the token are also revoked.
	Revoke(ctx context.Context, in *CredentialRevokeRequest, opts ...grpc.CallOption) (*CredentialRevokeResponse, error)
}

type credentialClient struct {
	cc grpc.ClientConnInterface
}

func NewCredentialClient(cc grpc.ClientConnInterface) CredentialClient {
	return &credentialClient{cc}
}

func (c *credentialClient) Issue(ctx context.Context, in *CredentialIssueRequest, opts ...grpc.CallOption) (*CredentialIssueResponse, error) {
	out := new(CredentialIssueResponse)
	err := c.cc.Invoke(ctx, "/plspb.Credential/Issue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *credentialClient) Refresh(ctx context.Context, in *CredentialRefreshRequest, opts ...grpc.CallOption) (*CredentialRefreshResponse, error) {
	out := new(CredentialRefreshResponse)
	err := c.cc.Invoke(ctx, "/plspb.Credential/Refresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *credentialClient) Revoke(ctx context.Context, in *CredentialRevokeRequest, opts ...grpc.CallOption) (*CredentialRevokeResponse, error) {
	out := new(CredentialRevokeResponse)
	err := c.cc.Invoke(ctx, "/plspb.Credential/Revoke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CredentialServer is the server API for Credential service.
// All implementations must embed UnimplementedCredentialServer
// for forward compatibility
type CredentialServer interface {
	// Issue creates a new token.
	//
	// If this request is authorized, a child token is created. The child token's
	// expiration may not exceed the expiration of the parent, and the child
	// token's contexts must be a subset of the parent's. When the parent token
	// is deleted, so are any children.
	Issue(context.Context, *CredentialIssueRequest) (*CredentialIssueResponse, error)
	// Refresh reissues a token with a new expiration. The returned credential
	// may or may not reuse the same identifier as the request.
	Refresh(context.Context, *CredentialRefreshRequest) (*CredentialRefreshResponse, error)
	// Revoke deletes a token and prevents it from being used again. Any children
	// of the token are also revoked.
	Revoke(context.Context, *CredentialRevokeRequest) (*CredentialRevokeResponse, error)
	mustEmbedUnimplementedCredentialServer()
}

// UnimplementedCredentialServer must be embedded to have forward compatible implementations.
type UnimplementedCredentialServer struct {
}

func (UnimplementedCredentialServer) Issue(context.Context, *CredentialIssueRequest) (*CredentialIssueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Issue not implemented")
}
func (UnimplementedCredentialServer) Refresh(context.Context, *CredentialRefreshRequest) (*CredentialRefreshResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedCredentialServer) Revoke(context.Context, *CredentialRevokeRequest) (*CredentialRevokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (UnimplementedCredentialServer) mustEmbedUnimplementedCredentialServer() {}

// UnsafeCredentialServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CredentialServer will
// result in compilation errors.
type UnsafeCredentialServer interface {
	mustEmbedUnimplementedCredentialServer()
}

func RegisterCredentialServer(s grpc.ServiceRegistrar, srv CredentialServer) {
	s.RegisterService(&Credential_ServiceDesc, srv)
}

func _Credential_Issue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialIssueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CredentialServer).Issue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plspb.Credential/Issue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CredentialServer).Issue(ctx, req.(*CredentialIssueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Credential_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialRefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CredentialServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plspb.Credential/Refresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CredentialServer).Refresh(ctx, req.(*CredentialRefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Credential_Revoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialRevokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CredentialServer).Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plspb.Credential/Revoke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CredentialServer).Revoke(ctx, req.(*CredentialRevokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Credential_ServiceDesc is the grpc.ServiceDesc for Credential service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Credential_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plspb.Credential",
	HandlerType: (*CredentialServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Issue",
			Handler:    _Credential_Issue_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _Credential_Refresh_Handler,
		},
		{
			MethodName: "Revoke",
			Handler:    _Credential_Revoke_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pls.proto",
}

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	// Create sets up a new log stream with a given context and name.
	Create(ctx context.Context, in *LogCreateRequest, opts ...grpc.CallOption) (*LogCreateResponse, error)
	// Delete removes access to an existing log stream. The log stream will no
	// longer be accessible to any client, although physical removal of data may
	// be delayed.
	Delete(ctx context.Context, in *LogDeleteRequest, opts ...grpc.CallOption) (*LogDeleteResponse, error)
	// List enumerates the log stream the authenticated credential has access to.
	List(ctx context.Context, in *LogListRequest, opts ...grpc.CallOption) (Log_ListClient, error)
	// MessageAppend adds a new message to the log stream. If the payload is
	// larger than 2MB, this RPC will return INVALID_ARGUMENT. If the service
	// needs to rate-limit this request, this RPC will return RESOURCE_EXHAUSTED
	// and additional information will be available in the QuotaFailure and
	// RetryInfo messages.
	MessageAppend(ctx context.Context, in *LogMessageAppendRequest, opts ...grpc.CallOption) (*LogMessageAppendResponse, error)
	// MessageList retrieves part or all of the messages in a log stream.
	// Messages are returned in the order received by the service.
	MessageList(ctx context.Context, in *LogMessageListRequest, opts ...grpc.CallOption) (Log_MessageListClient, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

func (c *logClient) Create(ctx context.Context, in *LogCreateRequest, opts ...grpc.CallOption) (*LogCreateResponse, error) {
	out := new(LogCreateResponse)
	err := c.cc.Invoke(ctx, "/plspb.Log/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) Delete(ctx context.Context, in *LogDeleteRequest, opts ...grpc.CallOption) (*LogDeleteResponse, error) {
	out := new(LogDeleteResponse)
	err := c.cc.Invoke(ctx, "/plspb.Log/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) List(ctx context.Context, in *LogListRequest, opts ...grpc.CallOption) (Log_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Log_ServiceDesc.Streams[0], "/plspb.Log/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &logListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Log_ListClient interface {
	Recv() (*LogListResponse, error)
	grpc.ClientStream
}

type logListClient struct {
	grpc.ClientStream
}

func (x *logListClient) Recv() (*LogListResponse, error) {
	m := new(LogListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logClient) MessageAppend(ctx context.Context, in *LogMessageAppendRequest, opts ...grpc.CallOption) (*LogMessageAppendResponse, error) {
	out := new(LogMessageAppendResponse)
	err := c.cc.Invoke(ctx, "/plspb.Log/MessageAppend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) MessageList(ctx context.Context, in *LogMessageListRequest, opts ...grpc.CallOption) (Log_MessageListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Log_ServiceDesc.Streams[1], "/plspb.Log/MessageList", opts...)
	if err != nil {
		return nil, err
	}
	x := &logMessageListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Log_MessageListClient interface {
	Recv() (*LogMessageListResponse, error)
	grpc.ClientStream
}

type logMessageListClient struct {
	grpc.ClientStream
}

func (x *logMessageListClient) Recv() (*LogMessageListResponse, error) {
	m := new(LogMessageListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LogServer is the server API for Log service.
// All implementations must embed UnimplementedLogServer
// for forward compatibility
type LogServer interface {
	// Create sets up a new log stream with a given context and name.
	Create(context.Context, *LogCreateRequest) (*LogCreateResponse, error)
	// Delete removes access to an existing log stream. The log stream will no
	// longer be accessible to any client, although physical removal of data may
	// be delayed.
	Delete(context.Context, *LogDeleteRequest) (*LogDeleteResponse, error)
	// List enumerates the log stream the authenticated credential has access to.
	List(*LogListRequest, Log_ListServer) error
	// MessageAppend adds a new message to the log stream. If the payload is
	// larger than 2MB, this RPC will return INVALID_ARGUMENT. If the service
	// needs to rate-limit this request, this RPC will return RESOURCE_EXHAUSTED
	// and additional information will be available in the QuotaFailure and
	// RetryInfo messages.
	MessageAppend(context.Context, *LogMessageAppendRequest) (*LogMessageAppendResponse, error)
	// MessageList retrieves part or all of the messages in a log stream.
	// Messages are returned in the order received by the service.
	MessageList(*LogMessageListRequest, Log_MessageListServer) error
	mustEmbedUnimplementedLogServer()
}

// UnimplementedLogServer must be embedded to have forward compatible implementations.
type UnimplementedLogServer struct {
}

func (UnimplementedLogServer) Create(context.Context, *LogCreateRequest) (*LogCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLogServer) Delete(context.Context, *LogDeleteRequest) (*LogDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLogServer) List(*LogListRequest, Log_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedLogServer) MessageAppend(context.Context, *LogMessageAppendRequest) (*LogMessageAppendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageAppend not implemented")
}
func (UnimplementedLogServer) MessageList(*LogMessageListRequest, Log_MessageListServer) error {
	return status.Errorf(codes.Unimplemented, "method MessageList not implemented")
}
func (UnimplementedLogServer) mustEmbedUnimplementedLogServer() {}

// UnsafeLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServer will
// result in compilation errors.
type UnsafeLogServer interface {
	mustEmbedUnimplementedLogServer()
}

func RegisterLogServer(s grpc.ServiceRegistrar, srv LogServer) {
	s.RegisterService(&Log_ServiceDesc, srv)
}

func _Log_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plspb.Log/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).Create(ctx, req.(*LogCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plspb.Log/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).Delete(ctx, req.(*LogDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogServer).List(m, &logListServer{stream})
}

type Log_ListServer interface {
	Send(*LogListResponse) error
	grpc.ServerStream
}

type logListServer struct {
	grpc.ServerStream
}

func (x *logListServer) Send(m *LogListResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Log_MessageAppend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogMessageAppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).MessageAppend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plspb.Log/MessageAppend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).MessageAppend(ctx, req.(*LogMessageAppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_MessageList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogMessageListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogServer).MessageList(m, &logMessageListServer{stream})
}

type Log_MessageListServer interface {
	Send(*LogMessageListResponse) error
	grpc.ServerStream
}

type logMessageListServer struct {
	grpc.ServerStream
}

func (x *logMessageListServer) Send(m *LogMessageListResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Log_ServiceDesc is the grpc.ServiceDesc for Log service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Log_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plspb.Log",
	HandlerType: (*LogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Log_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Log_Delete_Handler,
		},
		{
			MethodName: "MessageAppend",
			Handler:    _Log_MessageAppend_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _Log_List_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MessageList",
			Handler:       _Log_MessageList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pls.proto",
}
